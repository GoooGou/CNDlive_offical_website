---
import type { MarkdownHeading } from 'astro';

interface Props {
  headings: MarkdownHeading[];
}

const { headings } = Astro.props;
const toc = headings; 
---

<nav class="toc-container">
  <div class="mb-4 text-sm font-bold text-zinc-400 uppercase tracking-wider">
    On this page
  </div>
  
  <ul class="flex flex-col space-y-2 text-sm">
    {toc.map((heading) => (
      <li>
        <a 
          href={`#${heading.slug}`} 
          class="toc-link block transition-all duration-200 border-l-2 py-1 text-zinc-500 border-transparent hover:text-white"
          data-slug={heading.slug}
          style={`padding-left: ${(heading.depth - 1) * 0.75}rem`}
        >
          {heading.text}
        </a>
      </li>
    ))}
  </ul>
</nav>

<script>
  // 1. 样式配置
  const ACTIVE_CLASS = ['text-[#AC121F]', 'font-bold', 'border-[#AC121F]', 'bg-[#AC121F]/5']; 
  const INACTIVE_CLASS = ['text-zinc-500', 'border-transparent']; 

  // 2. 核心逻辑封装
  function initTOC() {
    const links = document.querySelectorAll('.toc-link');
    const sections = document.querySelectorAll('main h1, main h2, main h3, main h4, main h5, main h6');
    
    // 如果没有目录，直接退出
    if (links.length === 0) return;

    // 辅助函数：应用样式
    function applyStyle(activeSlug: string | null) {
      links.forEach((link) => {
        const linkSlug = link.getAttribute('data-slug');
        if (linkSlug === activeSlug) {
          link.classList.remove(...INACTIVE_CLASS);
          link.classList.add(...ACTIVE_CLASS);
        } else {
          link.classList.remove(...ACTIVE_CLASS);
          link.classList.add(...INACTIVE_CLASS);
        }
      });
    }

    // 核心计算函数：找出当前应该高亮的 ID
    function onScroll() {
      let currentActiveSlug = '';
      const scrollY = window.scrollY;
      const windowHeight = window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight;

      // 场景 A: 如果滚到底部了，强制高亮最后一个
      if (scrollY + windowHeight >= documentHeight - 50) {
         const lastLink = links[links.length - 1];
         if (lastLink) {
            applyStyle(lastLink.getAttribute('data-slug'));
            return;
         }
      }

      // 场景 B: 遍历所有标题，找出“视口顶部”附近的那个
      // 我们设定一条“阅读线”，在屏幕顶部下方 100px 处
      const offset = 100; 
      
      sections.forEach((section) => {
        // @ts-ignore
        const sectionTop = section.offsetTop; 
        
        // 如果页面滚动的距离 >= 标题的位置 - 偏移量
        // 说明这个标题已经滚上去了（或者正好在阅读位置）
        if (scrollY >= sectionTop - offset) {
          currentActiveSlug = section.id;
        }
      });

      // 场景 C: 如果一个都没选中（比如在页面最顶端），默认选第一个
      if (!currentActiveSlug && links.length > 0) {
        currentActiveSlug = links[0].getAttribute('data-slug') || '';
      }

      applyStyle(currentActiveSlug);
    }

    // 3. 性能优化：使用 requestAnimationFrame 进行节流
    let ticking = false;
    window.addEventListener('scroll', () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          onScroll();
          ticking = false;
        });
        ticking = true;
      }
    });

    // 4. 点击事件：点击瞬间高亮，不用等滚动
    links.forEach((link) => {
      link.addEventListener('click', (e) => {
        const slug = link.getAttribute('data-slug');
        applyStyle(slug);
      });
    });

    // 5. 初始化：页面刚加载完，手动算一次！解决刷新不红的问题
    onScroll();
  }

  // 启动 (兼容 Astro View Transitions)
  initTOC();
  document.addEventListener('astro:page-load', initTOC);

</script>

<style>
  .toc-container {
    position: sticky;
    top: 6rem; 
    max-height: calc(100vh - 200px);
    overflow-y: auto;
    scrollbar-width: none;
  }
</style>